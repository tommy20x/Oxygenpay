// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: payments.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
public_id,
created_at,
updated_at,
type,
status,
merchant_id,
merchant_order_uuid,
merchant_order_id,
expires_at,
price,
decimals,
currency,
description,
redirect_url,
metadata,
is_test
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata
`

type CreatePaymentParams struct {
	PublicID          uuid.UUID
	CreatedAt         time.Time
	UpdatedAt         time.Time
	Type              string
	Status            string
	MerchantID        int64
	MerchantOrderUuid uuid.UUID
	MerchantOrderID   sql.NullString
	ExpiresAt         sql.NullTime
	Price             pgtype.Numeric
	Decimals          int32
	Currency          string
	Description       sql.NullString
	RedirectUrl       string
	Metadata          pgtype.JSONB
	IsTest            bool
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.PublicID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Type,
		arg.Status,
		arg.MerchantID,
		arg.MerchantOrderUuid,
		arg.MerchantOrderID,
		arg.ExpiresAt,
		arg.Price,
		arg.Decimals,
		arg.Currency,
		arg.Description,
		arg.RedirectUrl,
		arg.Metadata,
		arg.IsTest,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const getBatchExpiredPayments = `-- name: GetBatchExpiredPayments :many
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata from payments
where (
  (expires_at is not null and expires_at < $2)
  or (expires_at is null and created_at < $3)
)
and type = $4
and status = any($5::varchar[])
order by id limit $1
`

type GetBatchExpiredPaymentsParams struct {
	Limit     int32
	ExpiresAt sql.NullTime
	CreatedAt time.Time
	Type      string
	Status    []string
}

func (q *Queries) GetBatchExpiredPayments(ctx context.Context, arg GetBatchExpiredPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getBatchExpiredPayments,
		arg.Limit,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Type,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Status,
			&i.MerchantID,
			&i.MerchantOrderUuid,
			&i.MerchantOrderID,
			&i.ExpiresAt,
			&i.Price,
			&i.Decimals,
			&i.Currency,
			&i.Description,
			&i.RedirectUrl,
			&i.CustomerID,
			&i.IsTest,
			&i.WebhookSentAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata FROM payments WHERE id = $1
and (CASE WHEN $3::boolean THEN merchant_id = $2 ELSE true END)
limit 1
`

type GetPaymentByIDParams struct {
	ID                 int64
	MerchantID         int64
	FilterByMerchantID bool
}

func (q *Queries) GetPaymentByID(ctx context.Context, arg GetPaymentByIDParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, arg.ID, arg.MerchantID, arg.FilterByMerchantID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const getPaymentByMerchantIDAndOrderUUID = `-- name: GetPaymentByMerchantIDAndOrderUUID :one
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata FROM payments
WHERE merchant_id = $1 and merchant_order_uuid = $2
LIMIT 1
`

type GetPaymentByMerchantIDAndOrderUUIDParams struct {
	MerchantID        int64
	MerchantOrderUuid uuid.UUID
}

func (q *Queries) GetPaymentByMerchantIDAndOrderUUID(ctx context.Context, arg GetPaymentByMerchantIDAndOrderUUIDParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByMerchantIDAndOrderUUID, arg.MerchantID, arg.MerchantOrderUuid)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const getPaymentByMerchantIDs = `-- name: GetPaymentByMerchantIDs :one
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata FROM payments WHERE merchant_id = $1 and merchant_order_uuid = $2
LIMIT 1
`

type GetPaymentByMerchantIDsParams struct {
	MerchantID        int64
	MerchantOrderUuid uuid.UUID
}

func (q *Queries) GetPaymentByMerchantIDs(ctx context.Context, arg GetPaymentByMerchantIDsParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByMerchantIDs, arg.MerchantID, arg.MerchantOrderUuid)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const getPaymentByPublicID = `-- name: GetPaymentByPublicID :one
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata FROM payments
WHERE public_id = $1
LIMIT 1
`

func (q *Queries) GetPaymentByPublicID(ctx context.Context, publicID uuid.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByPublicID, publicID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const getPaymentsByType = `-- name: GetPaymentsByType :many
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata from payments
where type = $1 and status = $2
and (CASE WHEN $4::boolean THEN id = any($5::int[]) ELSE true END)
order by id limit $3
`

type GetPaymentsByTypeParams struct {
	Type        string
	Status      string
	Limit       int32
	FilterByIds bool
	ID          []int32
}

func (q *Queries) GetPaymentsByType(ctx context.Context, arg GetPaymentsByTypeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByType,
		arg.Type,
		arg.Status,
		arg.Limit,
		arg.FilterByIds,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Status,
			&i.MerchantID,
			&i.MerchantOrderUuid,
			&i.MerchantOrderID,
			&i.ExpiresAt,
			&i.Price,
			&i.Decimals,
			&i.Currency,
			&i.Description,
			&i.RedirectUrl,
			&i.CustomerID,
			&i.IsTest,
			&i.WebhookSentAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatePaymentsAsc = `-- name: PaginatePaymentsAsc :many
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata from payments
WHERE merchant_id = $1 and id >= $2
AND (CASE WHEN $4::boolean THEN type = any($5::varchar[]) ELSE true END)
ORDER BY id LIMIT $3
`

type PaginatePaymentsAscParams struct {
	MerchantID    int64
	ID            int64
	Limit         int32
	FilterByTypes bool
	Type          []string
}

func (q *Queries) PaginatePaymentsAsc(ctx context.Context, arg PaginatePaymentsAscParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, paginatePaymentsAsc,
		arg.MerchantID,
		arg.ID,
		arg.Limit,
		arg.FilterByTypes,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Status,
			&i.MerchantID,
			&i.MerchantOrderUuid,
			&i.MerchantOrderID,
			&i.ExpiresAt,
			&i.Price,
			&i.Decimals,
			&i.Currency,
			&i.Description,
			&i.RedirectUrl,
			&i.CustomerID,
			&i.IsTest,
			&i.WebhookSentAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatePaymentsDesc = `-- name: PaginatePaymentsDesc :many
SELECT id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata from payments
WHERE merchant_id = $1 and id <= $2
AND (CASE WHEN $4::boolean THEN type = any($5::varchar[]) ELSE true END)
ORDER BY id desc LIMIT $3
`

type PaginatePaymentsDescParams struct {
	MerchantID    int64
	ID            int64
	Limit         int32
	FilterByTypes bool
	Type          []string
}

func (q *Queries) PaginatePaymentsDesc(ctx context.Context, arg PaginatePaymentsDescParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, paginatePaymentsDesc,
		arg.MerchantID,
		arg.ID,
		arg.Limit,
		arg.FilterByTypes,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Status,
			&i.MerchantID,
			&i.MerchantOrderUuid,
			&i.MerchantOrderID,
			&i.ExpiresAt,
			&i.Price,
			&i.Decimals,
			&i.Currency,
			&i.Description,
			&i.RedirectUrl,
			&i.CustomerID,
			&i.IsTest,
			&i.WebhookSentAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
set status = $3,
updated_at = $4,
expires_at = (CASE WHEN $6::boolean THEN $5 ELSE payments.expires_at END)
WHERE id = $1 and merchant_id = $2
returning id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata
`

type UpdatePaymentParams struct {
	ID           int64
	MerchantID   int64
	Status       string
	UpdatedAt    time.Time
	ExpiresAt    sql.NullTime
	SetExpiresAt bool
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.ID,
		arg.MerchantID,
		arg.Status,
		arg.UpdatedAt,
		arg.ExpiresAt,
		arg.SetExpiresAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Status,
		&i.MerchantID,
		&i.MerchantOrderUuid,
		&i.MerchantOrderID,
		&i.ExpiresAt,
		&i.Price,
		&i.Decimals,
		&i.Currency,
		&i.Description,
		&i.RedirectUrl,
		&i.CustomerID,
		&i.IsTest,
		&i.WebhookSentAt,
		&i.Metadata,
	)
	return i, err
}

const updatePaymentCustomerID = `-- name: UpdatePaymentCustomerID :exec
UPDATE payments set customer_id = $1 where id = $2
`

type UpdatePaymentCustomerIDParams struct {
	CustomerID sql.NullInt64
	ID         int64
}

func (q *Queries) UpdatePaymentCustomerID(ctx context.Context, arg UpdatePaymentCustomerIDParams) error {
	_, err := q.db.Exec(ctx, updatePaymentCustomerID, arg.CustomerID, arg.ID)
	return err
}

const updatePaymentWebhookInfo = `-- name: UpdatePaymentWebhookInfo :exec
UPDATE payments set webhook_sent_at = $3, updated_at = $4
WHERE id = $1 and merchant_id = $2
`

type UpdatePaymentWebhookInfoParams struct {
	ID            int64
	MerchantID    int64
	WebhookSentAt sql.NullTime
	UpdatedAt     time.Time
}

func (q *Queries) UpdatePaymentWebhookInfo(ctx context.Context, arg UpdatePaymentWebhookInfoParams) error {
	_, err := q.db.Exec(ctx, updatePaymentWebhookInfo,
		arg.ID,
		arg.MerchantID,
		arg.WebhookSentAt,
		arg.UpdatedAt,
	)
	return err
}
