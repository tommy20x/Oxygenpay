// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transactions.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const cancelTransaction = `-- name: CancelTransaction :exec
update transactions
set status = $2,
updated_at = $3,
metadata = $4,
network_fee = CASE WHEN $6::boolean THEN $5 ELSE transactions.network_fee END
where id = $1
`

type CancelTransactionParams struct {
	ID            int64
	Status        string
	UpdatedAt     time.Time
	Metadata      pgtype.JSONB
	NetworkFee    pgtype.Numeric
	SetNetworkFee bool
}

func (q *Queries) CancelTransaction(ctx context.Context, arg CancelTransactionParams) error {
	_, err := q.db.Exec(ctx, cancelTransaction,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.Metadata,
		arg.NetworkFee,
		arg.SetNetworkFee,
	)
	return err
}

const createTransaction = `-- name: CreateTransaction :one
insert into transactions (
      merchant_id,
      created_at, updated_at,
      status, type, entity_id,
      sender_wallet_id, sender_address,
      recipient_wallet_id, recipient_address,
      transaction_hash,
      blockchain, network_id, currency_type, currency, decimals, network_decimals,
      amount, fact_amount, network_fee, service_fee, usd_amount,
      metadata, is_test
)
values (
      $1, $2, $3, $4, $5, $6,
      $7, $8, $9, $10, $11, $12,
      $13, $14, $15, $16, $17, $18,
      $19, $20, $21, $22, $23, $24
) returning id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id
`

type CreateTransactionParams struct {
	MerchantID        int64
	CreatedAt         time.Time
	UpdatedAt         time.Time
	Status            string
	Type              string
	EntityID          sql.NullInt64
	SenderWalletID    sql.NullInt64
	SenderAddress     sql.NullString
	RecipientWalletID sql.NullInt64
	RecipientAddress  string
	TransactionHash   sql.NullString
	Blockchain        string
	NetworkID         sql.NullString
	CurrencyType      string
	Currency          string
	Decimals          int32
	NetworkDecimals   int32
	Amount            pgtype.Numeric
	FactAmount        pgtype.Numeric
	NetworkFee        pgtype.Numeric
	ServiceFee        pgtype.Numeric
	UsdAmount         pgtype.Numeric
	Metadata          pgtype.JSONB
	IsTest            bool
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.MerchantID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
		arg.Type,
		arg.EntityID,
		arg.SenderWalletID,
		arg.SenderAddress,
		arg.RecipientWalletID,
		arg.RecipientAddress,
		arg.TransactionHash,
		arg.Blockchain,
		arg.NetworkID,
		arg.CurrencyType,
		arg.Currency,
		arg.Decimals,
		arg.NetworkDecimals,
		arg.Amount,
		arg.FactAmount,
		arg.NetworkFee,
		arg.ServiceFee,
		arg.UsdAmount,
		arg.Metadata,
		arg.IsTest,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Status,
		&i.Type,
		&i.EntityID,
		&i.RecipientWalletID,
		&i.SenderAddress,
		&i.RecipientAddress,
		&i.TransactionHash,
		&i.Blockchain,
		&i.CurrencyType,
		&i.Currency,
		&i.Decimals,
		&i.Amount,
		&i.FactAmount,
		&i.NetworkFee,
		&i.ServiceFee,
		&i.UsdAmount,
		&i.Metadata,
		&i.NetworkID,
		&i.IsTest,
		&i.NetworkDecimals,
		&i.SenderWalletID,
	)
	return i, err
}

const eagerLoadTransactionsByPaymentID = `-- name: EagerLoadTransactionsByPaymentID :many
select distinct on (entity_id) id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id from transactions
where merchant_id = $1 and entity_id = any($2::int[])
and entity_id = any($2::int[])
and type = any($3::varchar[])
order by entity_id desc, id desc
`

type EagerLoadTransactionsByPaymentIDParams struct {
	MerchantID int64
	EntityIds  []int32
	Type       []string
}

func (q *Queries) EagerLoadTransactionsByPaymentID(ctx context.Context, arg EagerLoadTransactionsByPaymentIDParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, eagerLoadTransactionsByPaymentID, arg.MerchantID, arg.EntityIds, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MerchantID,
			&i.Status,
			&i.Type,
			&i.EntityID,
			&i.RecipientWalletID,
			&i.SenderAddress,
			&i.RecipientAddress,
			&i.TransactionHash,
			&i.Blockchain,
			&i.CurrencyType,
			&i.Currency,
			&i.Decimals,
			&i.Amount,
			&i.FactAmount,
			&i.NetworkFee,
			&i.ServiceFee,
			&i.UsdAmount,
			&i.Metadata,
			&i.NetworkID,
			&i.IsTest,
			&i.NetworkDecimals,
			&i.SenderWalletID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestTransactionByPaymentID = `-- name: GetLatestTransactionByPaymentID :one
select id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id from transactions where entity_id = $1 order by id desc limit 1
`

func (q *Queries) GetLatestTransactionByPaymentID(ctx context.Context, entityID sql.NullInt64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getLatestTransactionByPaymentID, entityID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Status,
		&i.Type,
		&i.EntityID,
		&i.RecipientWalletID,
		&i.SenderAddress,
		&i.RecipientAddress,
		&i.TransactionHash,
		&i.Blockchain,
		&i.CurrencyType,
		&i.Currency,
		&i.Decimals,
		&i.Amount,
		&i.FactAmount,
		&i.NetworkFee,
		&i.ServiceFee,
		&i.UsdAmount,
		&i.Metadata,
		&i.NetworkID,
		&i.IsTest,
		&i.NetworkDecimals,
		&i.SenderWalletID,
	)
	return i, err
}

const getTransactionByHashAndNetworkID = `-- name: GetTransactionByHashAndNetworkID :one
select id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id from transactions where transaction_hash = $1 and network_id = $2 limit 1
`

type GetTransactionByHashAndNetworkIDParams struct {
	TransactionHash sql.NullString
	NetworkID       sql.NullString
}

func (q *Queries) GetTransactionByHashAndNetworkID(ctx context.Context, arg GetTransactionByHashAndNetworkIDParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByHashAndNetworkID, arg.TransactionHash, arg.NetworkID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Status,
		&i.Type,
		&i.EntityID,
		&i.RecipientWalletID,
		&i.SenderAddress,
		&i.RecipientAddress,
		&i.TransactionHash,
		&i.Blockchain,
		&i.CurrencyType,
		&i.Currency,
		&i.Decimals,
		&i.Amount,
		&i.FactAmount,
		&i.NetworkFee,
		&i.ServiceFee,
		&i.UsdAmount,
		&i.Metadata,
		&i.NetworkID,
		&i.IsTest,
		&i.NetworkDecimals,
		&i.SenderWalletID,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
select id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id from transactions where id = $1
and (CASE WHEN $3::boolean THEN merchant_id = $2 ELSE true END)
`

type GetTransactionByIDParams struct {
	ID                 int64
	MerchantID         int64
	FilterByMerchantID bool
}

func (q *Queries) GetTransactionByID(ctx context.Context, arg GetTransactionByIDParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, arg.ID, arg.MerchantID, arg.FilterByMerchantID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Status,
		&i.Type,
		&i.EntityID,
		&i.RecipientWalletID,
		&i.SenderAddress,
		&i.RecipientAddress,
		&i.TransactionHash,
		&i.Blockchain,
		&i.CurrencyType,
		&i.Currency,
		&i.Decimals,
		&i.Amount,
		&i.FactAmount,
		&i.NetworkFee,
		&i.ServiceFee,
		&i.UsdAmount,
		&i.Metadata,
		&i.NetworkID,
		&i.IsTest,
		&i.NetworkDecimals,
		&i.SenderWalletID,
	)
	return i, err
}

const getTransactionsByFilter = `-- name: GetTransactionsByFilter :many
select id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id from transactions
where (CASE WHEN $5::boolean THEN recipient_wallet_id = $1 ELSE true END)
and (CASE WHEN $6::boolean THEN network_id = $2 ELSE true END)
and (CASE WHEN $7::boolean THEN currency = $3 ELSE true END)
and (CASE WHEN $8::boolean THEN type = any($9::varchar[]) ELSE true END)
and (CASE WHEN $10::boolean THEN status = any($11::varchar[]) ELSE true END)
and (CASE WHEN $12::boolean THEN transaction_hash is null ELSE true END)
order by id desc
limit $4
`

type GetTransactionsByFilterParams struct {
	RecipientWalletID         sql.NullInt64
	NetworkID                 sql.NullString
	Currency                  string
	Limit                     int32
	FilterByRecipientWalletID bool
	FilterByNetworkID         bool
	FilterByCurrency          bool
	FilterByTypes             bool
	Types                     []string
	FilterByStatuses          bool
	Statuses                  []string
	FilterEmptyHash           bool
}

func (q *Queries) GetTransactionsByFilter(ctx context.Context, arg GetTransactionsByFilterParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByFilter,
		arg.RecipientWalletID,
		arg.NetworkID,
		arg.Currency,
		arg.Limit,
		arg.FilterByRecipientWalletID,
		arg.FilterByNetworkID,
		arg.FilterByCurrency,
		arg.FilterByTypes,
		arg.Types,
		arg.FilterByStatuses,
		arg.Statuses,
		arg.FilterEmptyHash,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MerchantID,
			&i.Status,
			&i.Type,
			&i.EntityID,
			&i.RecipientWalletID,
			&i.SenderAddress,
			&i.RecipientAddress,
			&i.TransactionHash,
			&i.Blockchain,
			&i.CurrencyType,
			&i.Currency,
			&i.Decimals,
			&i.Amount,
			&i.FactAmount,
			&i.NetworkFee,
			&i.ServiceFee,
			&i.UsdAmount,
			&i.Metadata,
			&i.NetworkID,
			&i.IsTest,
			&i.NetworkDecimals,
			&i.SenderWalletID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTransactionHash = `-- name: SetTransactionHash :exec
update transactions set transaction_hash = $1, updated_at = $2 where id = $3 and merchant_id = $4
`

type SetTransactionHashParams struct {
	TransactionHash sql.NullString
	UpdatedAt       time.Time
	ID              int64
	MerchantID      int64
}

func (q *Queries) SetTransactionHash(ctx context.Context, arg SetTransactionHashParams) error {
	_, err := q.db.Exec(ctx, setTransactionHash,
		arg.TransactionHash,
		arg.UpdatedAt,
		arg.ID,
		arg.MerchantID,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :one
update transactions set
status = $3,
updated_at = $4,
sender_address = $5,
fact_amount = $6,
transaction_hash = $7,
network_fee = $8,
service_fee = CASE WHEN $10::boolean THEN 0 ELSE transactions.service_fee END,
metadata = $9
where merchant_id = $1 and id = $2
returning id, created_at, updated_at, merchant_id, status, type, entity_id, recipient_wallet_id, sender_address, recipient_address, transaction_hash, blockchain, currency_type, currency, decimals, amount, fact_amount, network_fee, service_fee, usd_amount, metadata, network_id, is_test, network_decimals, sender_wallet_id
`

type UpdateTransactionParams struct {
	MerchantID       int64
	ID               int64
	Status           string
	UpdatedAt        time.Time
	SenderAddress    sql.NullString
	FactAmount       pgtype.Numeric
	TransactionHash  sql.NullString
	NetworkFee       pgtype.Numeric
	Metadata         pgtype.JSONB
	RemoveServiceFee bool
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.MerchantID,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.SenderAddress,
		arg.FactAmount,
		arg.TransactionHash,
		arg.NetworkFee,
		arg.Metadata,
		arg.RemoveServiceFee,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Status,
		&i.Type,
		&i.EntityID,
		&i.RecipientWalletID,
		&i.SenderAddress,
		&i.RecipientAddress,
		&i.TransactionHash,
		&i.Blockchain,
		&i.CurrencyType,
		&i.Currency,
		&i.Decimals,
		&i.Amount,
		&i.FactAmount,
		&i.NetworkFee,
		&i.ServiceFee,
		&i.UsdAmount,
		&i.Metadata,
		&i.NetworkID,
		&i.IsTest,
		&i.NetworkDecimals,
		&i.SenderWalletID,
	)
	return i, err
}
