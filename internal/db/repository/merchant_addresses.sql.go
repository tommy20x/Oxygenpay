// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: merchant_addresses.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMerchantAddress = `-- name: CreateMerchantAddress :one
insert into merchant_addresses(
    created_at, updated_at,
    uuid,
    merchant_id, name, blockchain,
    address
) values ($1, $2, $3, $4, $5, $6, $7)
returning id, uuid, created_at, updated_at, merchant_id, name, blockchain, address
`

type CreateMerchantAddressParams struct {
	CreatedAt  time.Time
	UpdatedAt  time.Time
	Uuid       uuid.UUID
	MerchantID int64
	Name       string
	Blockchain string
	Address    string
}

func (q *Queries) CreateMerchantAddress(ctx context.Context, arg CreateMerchantAddressParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, createMerchantAddress,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Uuid,
		arg.MerchantID,
		arg.Name,
		arg.Blockchain,
		arg.Address,
	)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Name,
		&i.Blockchain,
		&i.Address,
	)
	return i, err
}

const deleteMerchantAddress = `-- name: DeleteMerchantAddress :exec
delete from merchant_addresses where merchant_id = $1 and id = $2
`

type DeleteMerchantAddressParams struct {
	MerchantID int64
	ID         int64
}

func (q *Queries) DeleteMerchantAddress(ctx context.Context, arg DeleteMerchantAddressParams) error {
	_, err := q.db.Exec(ctx, deleteMerchantAddress, arg.MerchantID, arg.ID)
	return err
}

const getMerchantAddressByAddress = `-- name: GetMerchantAddressByAddress :one
select id, uuid, created_at, updated_at, merchant_id, name, blockchain, address from merchant_addresses
where merchant_id = $1 and address = $2 and blockchain = $3
limit 1
`

type GetMerchantAddressByAddressParams struct {
	MerchantID int64
	Address    string
	Blockchain string
}

func (q *Queries) GetMerchantAddressByAddress(ctx context.Context, arg GetMerchantAddressByAddressParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, getMerchantAddressByAddress, arg.MerchantID, arg.Address, arg.Blockchain)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Name,
		&i.Blockchain,
		&i.Address,
	)
	return i, err
}

const getMerchantAddressByID = `-- name: GetMerchantAddressByID :one
select id, uuid, created_at, updated_at, merchant_id, name, blockchain, address from merchant_addresses
where merchant_id = $1 and id = $2
limit 1
`

type GetMerchantAddressByIDParams struct {
	MerchantID int64
	ID         int64
}

func (q *Queries) GetMerchantAddressByID(ctx context.Context, arg GetMerchantAddressByIDParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, getMerchantAddressByID, arg.MerchantID, arg.ID)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Name,
		&i.Blockchain,
		&i.Address,
	)
	return i, err
}

const getMerchantAddressByUUID = `-- name: GetMerchantAddressByUUID :one
select id, uuid, created_at, updated_at, merchant_id, name, blockchain, address from merchant_addresses
where merchant_id = $1 and uuid = $2
limit 1
`

type GetMerchantAddressByUUIDParams struct {
	MerchantID int64
	Uuid       uuid.UUID
}

func (q *Queries) GetMerchantAddressByUUID(ctx context.Context, arg GetMerchantAddressByUUIDParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, getMerchantAddressByUUID, arg.MerchantID, arg.Uuid)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Name,
		&i.Blockchain,
		&i.Address,
	)
	return i, err
}

const listMerchantAddresses = `-- name: ListMerchantAddresses :many
select id, uuid, created_at, updated_at, merchant_id, name, blockchain, address from merchant_addresses
where merchant_id = $1
order by id desc
`

func (q *Queries) ListMerchantAddresses(ctx context.Context, merchantID int64) ([]MerchantAddress, error) {
	rows, err := q.db.Query(ctx, listMerchantAddresses, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MerchantAddress
	for rows.Next() {
		var i MerchantAddress
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MerchantID,
			&i.Name,
			&i.Blockchain,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMerchantAddress = `-- name: UpdateMerchantAddress :one
update merchant_addresses
set name = $3, updated_at = $4
where merchant_id = $1 and id = $2
returning id, uuid, created_at, updated_at, merchant_id, name, blockchain, address
`

type UpdateMerchantAddressParams struct {
	MerchantID int64
	ID         int64
	Name       string
	UpdatedAt  time.Time
}

func (q *Queries) UpdateMerchantAddress(ctx context.Context, arg UpdateMerchantAddressParams) (MerchantAddress, error) {
	row := q.db.QueryRow(ctx, updateMerchantAddress,
		arg.MerchantID,
		arg.ID,
		arg.Name,
		arg.UpdatedAt,
	)
	var i MerchantAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MerchantID,
		&i.Name,
		&i.Blockchain,
		&i.Address,
	)
	return i, err
}
