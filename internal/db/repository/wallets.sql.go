// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: wallets.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSystemWalletExistsByAddress = `-- name: CheckSystemWalletExistsByAddress :one
SELECT id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions from wallets where address = $1 limit 1
`

func (q *Queries) CheckSystemWalletExistsByAddress(ctx context.Context, address string) (Wallet, error) {
	row := q.db.QueryRow(ctx, checkSystemWalletExistsByAddress, address)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (
    created_at,
    uuid,
    address,
    blockchain,
    type
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions
`

type CreateWalletParams struct {
	CreatedAt  time.Time
	Uuid       uuid.UUID
	Address    string
	Blockchain string
	Type       sql.NullString
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.CreatedAt,
		arg.Uuid,
		arg.Address,
		arg.Blockchain,
		arg.Type,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const createWalletLock = `-- name: CreateWalletLock :one
INSERT INTO wallet_locks (
    merchant_id,
    wallet_id,
    currency,
    network_id,
    locked_at,
    locked_until
) VALUES ($1, $2, $3, $4, $5, $6)
returning id, wallet_id, merchant_id, currency, network_id, locked_at, locked_until
`

type CreateWalletLockParams struct {
	MerchantID  int64
	WalletID    int64
	Currency    string
	NetworkID   string
	LockedAt    time.Time
	LockedUntil sql.NullTime
}

func (q *Queries) CreateWalletLock(ctx context.Context, arg CreateWalletLockParams) (WalletLock, error) {
	row := q.db.QueryRow(ctx, createWalletLock,
		arg.MerchantID,
		arg.WalletID,
		arg.Currency,
		arg.NetworkID,
		arg.LockedAt,
		arg.LockedUntil,
	)
	var i WalletLock
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.MerchantID,
		&i.Currency,
		&i.NetworkID,
		&i.LockedAt,
		&i.LockedUntil,
	)
	return i, err
}

const getAvailableWallet = `-- name: GetAvailableWallet :one
SELECT wallets.id, wallets.created_at, wallets.uuid, wallets.address, wallets.blockchain, wallets.tatum_mainnet_subscription_id, wallets.tatum_testnet_subscription_id, wallets.type, wallets.confirmed_mainnet_transactions, wallets.pending_mainnet_transactions, wallets.pending_testnet_transactions, wallets.confirmed_testnet_transactions
FROM wallets
WHERE blockchain = $1 and type = $2
AND NOT EXISTS(
    select id from wallet_locks
    where wallet_id = wallets.id and currency = $3 and network_id = $4
)
order by id
LIMIT 1
`

type GetAvailableWalletParams struct {
	Blockchain string
	Type       sql.NullString
	Currency   string
	NetworkID  string
}

func (q *Queries) GetAvailableWallet(ctx context.Context, arg GetAvailableWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getAvailableWallet,
		arg.Blockchain,
		arg.Type,
		arg.Currency,
		arg.NetworkID,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions
FROM wallets
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetWalletByID(ctx context.Context, id int64) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const getWalletByUUID = `-- name: GetWalletByUUID :one
SELECT id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions
FROM wallets
WHERE uuid = $1
LIMIT 1
`

func (q *Queries) GetWalletByUUID(ctx context.Context, uuid uuid.UUID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByUUID, uuid)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const getWalletForUpdateByID = `-- name: GetWalletForUpdateByID :one
SELECT id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions FROM wallets WHERE id = $1 LIMIT 1 FOR NO KEY UPDATE
`

func (q *Queries) GetWalletForUpdateByID(ctx context.Context, id int64) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletForUpdateByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const getWalletLock = `-- name: GetWalletLock :one
select id, wallet_id, merchant_id, currency, network_id, locked_at, locked_until from wallet_locks where wallet_id = $1 and currency = $2 and network_id = $3 limit 1
`

type GetWalletLockParams struct {
	WalletID  int64
	Currency  string
	NetworkID string
}

func (q *Queries) GetWalletLock(ctx context.Context, arg GetWalletLockParams) (WalletLock, error) {
	row := q.db.QueryRow(ctx, getWalletLock, arg.WalletID, arg.Currency, arg.NetworkID)
	var i WalletLock
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.MerchantID,
		&i.Currency,
		&i.NetworkID,
		&i.LockedAt,
		&i.LockedUntil,
	)
	return i, err
}

const paginateWalletsByID = `-- name: PaginateWalletsByID :many
SELECT id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions
FROM wallets
WHERE id >= $1
AND (CASE WHEN $5::bool THEN type = $4 ELSE true END)
AND (CASE WHEN $6::bool THEN blockchain = $3 ELSE true END)
order by id
LIMIT $2
`

type PaginateWalletsByIDParams struct {
	ID                 int64
	Limit              int32
	Blockchain         string
	Type               sql.NullString
	FilterByType       bool
	FilterByBlockchain bool
}

func (q *Queries) PaginateWalletsByID(ctx context.Context, arg PaginateWalletsByIDParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, paginateWalletsByID,
		arg.ID,
		arg.Limit,
		arg.Blockchain,
		arg.Type,
		arg.FilterByType,
		arg.FilterByBlockchain,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Uuid,
			&i.Address,
			&i.Blockchain,
			&i.TatumMainnetSubscriptionID,
			&i.TatumTestnetSubscriptionID,
			&i.Type,
			&i.ConfirmedMainnetTransactions,
			&i.PendingMainnetTransactions,
			&i.PendingTestnetTransactions,
			&i.ConfirmedTestnetTransactions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseWalletLock = `-- name: ReleaseWalletLock :exec
DELETE from wallet_locks where id = $1
`

func (q *Queries) ReleaseWalletLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, releaseWalletLock, id)
	return err
}

const updateWalletMainnetTransactionCounters = `-- name: UpdateWalletMainnetTransactionCounters :exec
update wallets set confirmed_mainnet_transactions = $2, pending_mainnet_transactions = $3 where id = $1
`

type UpdateWalletMainnetTransactionCountersParams struct {
	ID                           int64
	ConfirmedMainnetTransactions int64
	PendingMainnetTransactions   int64
}

func (q *Queries) UpdateWalletMainnetTransactionCounters(ctx context.Context, arg UpdateWalletMainnetTransactionCountersParams) error {
	_, err := q.db.Exec(ctx, updateWalletMainnetTransactionCounters, arg.ID, arg.ConfirmedMainnetTransactions, arg.PendingMainnetTransactions)
	return err
}

const updateWalletTatumFields = `-- name: UpdateWalletTatumFields :one
UPDATE wallets
SET tatum_mainnet_subscription_id = $1,
    tatum_testnet_subscription_id = $2
WHERE id = $3
RETURNING id, created_at, uuid, address, blockchain, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, type, confirmed_mainnet_transactions, pending_mainnet_transactions, pending_testnet_transactions, confirmed_testnet_transactions
`

type UpdateWalletTatumFieldsParams struct {
	TatumMainnetSubscriptionID sql.NullString
	TatumTestnetSubscriptionID sql.NullString
	ID                         int64
}

func (q *Queries) UpdateWalletTatumFields(ctx context.Context, arg UpdateWalletTatumFieldsParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletTatumFields, arg.TatumMainnetSubscriptionID, arg.TatumTestnetSubscriptionID, arg.ID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Address,
		&i.Blockchain,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.Type,
		&i.ConfirmedMainnetTransactions,
		&i.PendingMainnetTransactions,
		&i.PendingTestnetTransactions,
		&i.ConfirmedTestnetTransactions,
	)
	return i, err
}

const updateWalletTestnetTransactionCounters = `-- name: UpdateWalletTestnetTransactionCounters :exec
update wallets set confirmed_testnet_transactions = $2, pending_testnet_transactions = $3 where id = $1
`

type UpdateWalletTestnetTransactionCountersParams struct {
	ID                           int64
	ConfirmedTestnetTransactions int64
	PendingTestnetTransactions   int64
}

func (q *Queries) UpdateWalletTestnetTransactionCounters(ctx context.Context, arg UpdateWalletTestnetTransactionCountersParams) error {
	_, err := q.db.Exec(ctx, updateWalletTestnetTransactionCounters, arg.ID, arg.ConfirmedTestnetTransactions, arg.PendingTestnetTransactions)
	return err
}
