// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: customers.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const calculateCustomerPayments = `-- name: CalculateCustomerPayments :one
select count(id) from payments
where merchant_id = $1 and customer_id = $2 and status = $3
group by merchant_id, customer_id, status
`

type CalculateCustomerPaymentsParams struct {
	MerchantID int64
	CustomerID sql.NullInt64
	Status     string
}

func (q *Queries) CalculateCustomerPayments(ctx context.Context, arg CalculateCustomerPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, calculateCustomerPayments, arg.MerchantID, arg.CustomerID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
uuid,
created_at,
updated_at,
email,
merchant_id
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, uuid, created_at, updated_at, email, merchant_id
`

type CreateCustomerParams struct {
	Uuid       uuid.UUID
	CreatedAt  time.Time
	UpdatedAt  time.Time
	Email      sql.NullString
	MerchantID int64
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.Uuid,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Email,
		arg.MerchantID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.MerchantID,
	)
	return i, err
}

const getBatchCustomers = `-- name: GetBatchCustomers :many
select id, uuid, created_at, updated_at, email, merchant_id from customers where merchant_id = $1 and id =  any($2::int[])
`

type GetBatchCustomersParams struct {
	MerchantID int64
	Ids        []int32
}

func (q *Queries) GetBatchCustomers(ctx context.Context, arg GetBatchCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, getBatchCustomers, arg.MerchantID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.MerchantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT id, uuid, created_at, updated_at, email, merchant_id FROM customers
WHERE email = $1 and merchant_id = $2
LIMIT 1
`

type GetCustomerByEmailParams struct {
	Email      sql.NullString
	MerchantID int64
}

func (q *Queries) GetCustomerByEmail(ctx context.Context, arg GetCustomerByEmailParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByEmail, arg.Email, arg.MerchantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.MerchantID,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT id, uuid, created_at, updated_at, email, merchant_id FROM customers
WHERE id = $1 and merchant_id = $2
LIMIT 1
`

type GetCustomerByIDParams struct {
	ID         int64
	MerchantID int64
}

func (q *Queries) GetCustomerByID(ctx context.Context, arg GetCustomerByIDParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByID, arg.ID, arg.MerchantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.MerchantID,
	)
	return i, err
}

const getCustomerByUUID = `-- name: GetCustomerByUUID :one
SELECT id, uuid, created_at, updated_at, email, merchant_id FROM customers
WHERE uuid = $1 and merchant_id = $2
LIMIT 1
`

type GetCustomerByUUIDParams struct {
	Uuid       uuid.UUID
	MerchantID int64
}

func (q *Queries) GetCustomerByUUID(ctx context.Context, arg GetCustomerByUUIDParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByUUID, arg.Uuid, arg.MerchantID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.MerchantID,
	)
	return i, err
}

const getRecentCustomerPayments = `-- name: GetRecentCustomerPayments :many
select id, public_id, created_at, updated_at, type, status, merchant_id, merchant_order_uuid, merchant_order_id, expires_at, price, decimals, currency, description, redirect_url, customer_id, is_test, webhook_sent_at, metadata from payments
where merchant_id = $1 and customer_id = $2
order by id desc limit $3
`

type GetRecentCustomerPaymentsParams struct {
	MerchantID int64
	CustomerID sql.NullInt64
	Limit      int32
}

func (q *Queries) GetRecentCustomerPayments(ctx context.Context, arg GetRecentCustomerPaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getRecentCustomerPayments, arg.MerchantID, arg.CustomerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Status,
			&i.MerchantID,
			&i.MerchantOrderUuid,
			&i.MerchantOrderID,
			&i.ExpiresAt,
			&i.Price,
			&i.Decimals,
			&i.Currency,
			&i.Description,
			&i.RedirectUrl,
			&i.CustomerID,
			&i.IsTest,
			&i.WebhookSentAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateCustomersAsc = `-- name: PaginateCustomersAsc :many
SELECT id, uuid, created_at, updated_at, email, merchant_id from customers
WHERE merchant_id = $1 and id >= $2
ORDER BY id LIMIT $3
`

type PaginateCustomersAscParams struct {
	MerchantID int64
	ID         int64
	Limit      int32
}

func (q *Queries) PaginateCustomersAsc(ctx context.Context, arg PaginateCustomersAscParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, paginateCustomersAsc, arg.MerchantID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.MerchantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginateCustomersDesc = `-- name: PaginateCustomersDesc :many
SELECT id, uuid, created_at, updated_at, email, merchant_id from customers
WHERE merchant_id = $1 and id <= $2
ORDER BY id desc LIMIT $3
`

type PaginateCustomersDescParams struct {
	MerchantID int64
	ID         int64
	Limit      int32
}

func (q *Queries) PaginateCustomersDesc(ctx context.Context, arg PaginateCustomersDescParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, paginateCustomersDesc, arg.MerchantID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.MerchantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
